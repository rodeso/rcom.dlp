## Transmissão Série Assíncrona
 - Transmissão Byte a Byte
 - Cada byte transmitido bit a bit
 - Byte definido por:
	 - start bit
	 - end bit
 - Receptor e Emissor cruzados

## Driver da Porta Série
 - Código-base disponibilizado:
	 -  openSerialPort, closeSerialPort, readByte, writeBytes


## Interface Protocolo-Aplicação
 - Emissor Aplicação com llwrite()
 - Receptor Aplicação com llread()
 - Receptor envia RR
Computadores só conseguem inferir sobre a informação que recebem


# Work overview

## Goals
- Implement a data link layer protocol, according to the specification provided in this document
- this protocol implements transmitter and receiver functionality to transfer a file stored on a computer hard disk between computers connected through a RS-232 serial cable
- Develop a simple transmitter and receiver data transfer application to test the protocol, according to the specification provided in this document
- the application to be developed uses/invokes the functions implemented by the data link layer protocol
-  the data link layer protocol thus offers/exposes an API to the upper layer

## Development environment
- PC running LINUX
- Programming language: C
- Serial port RS-232 (asynchronous communication)


# Evaluation

## Organization

- Groups of 2 elements
- Each group develops the transmitter and receiver

## Evaluation criteria

- Participation during class (continuous evaluation)
- Presentation and demonstration of the work on 5 milestones
	- M1: Exchange strings over serial connections;
	- M2: Sending and receiving control frame (SET/UA) and state machine in llopen;
	- M3: Implement the Stop & Wait protocol in llwrite and llread;
	- M4: Timer and retransmission;
	- M5: Application layer implementation and correct API operation of llopen, llclose, llwrite, llread;
- Individual 15-minute quiz to be answered in the classroom, on the last class before the presentation
- Final report

# _Data Link Protocol -_ _Goal and General Functionality_

## Goal of the Data Link Layer Protocol

- Provide reliable communication between two systems connected by a communication medium – in this case, a serial cable
## Generic functions of data link protocols

Framing
- Packaging and synchronisation/delimitation
	- Packaging - data coming from the upper layer is packed into frames
		- frames have an header, a body and a trailer
		- user/application data goes into the body section
		- these frames are designated as information frames
	- Frame synchronisation (delimitation)
		- start and end of frames are uniquely identified so that data reception can become synchronised
			- main alternative is to use a special character/flag at the beginning and end of frames
			- need to make sure that its value does not occur elsewhere inside the frame
				- transparency or stuffing mechanism (explained in slides 16 and 17)
		- the size of frames may be implicitly determined
			- by counting the number of bytes in between synchronisation flags
		- or explicitly indicated
			- in one field of the header
Connection establishment and termination
- exchange of specific messages sent in fixed-length frames
	- designated of supervision frames having only control fields (no user data)
Frame numbering
- a counter module-n in the header of frames to allow to verify the correct sequence of information frames and/or the occurrence of duplicates
Acknowledgement
- every time a frame is received without errors and in the right sequence a positive acknowledgement is sent back to the sender
Error control (e.g.: Stop-and-Wait, Go-back-N, Selective Repeat)
- use of timers (time-out) to enable re-transmission of un-acknowledged frames
- use of negative acknowledgement to request the retransmission of out-of-sequence or errored frames
- verification of duplicates which may occur due to re-transmissions
Flow control

## Specification

The protocol to implement combines characteristics of existing real-world data link protocols
- agnostic to the type of user data to be transferred (independence and transparency)
- transmission organised into frames, which can be of three types
	- Information (I), Supervision (S) and Unnumbered (U)
- Frames have a header with a common format
	- only Information frames have a field for user data transport
		- a field to transport a packet generated by the application, which content is not processed by the data link protocol

- Frame delimiting is done by means of a special eight-bit sequence (flag) and a byte stuffing technique ensures that this value will not occur inside the frame (explained in slide 17)
- The frames are protected by an error detection code
	- In frames S and U there is simple frame protection (since they do not carry data)
	- In I frames there is double and independent protection of the header and the data field (which allows to use a valid header, even if an error occurs in the data field)
-  The Stop and Wait variant is used (unit window and modulo 2 numbering)

## Packets and Frames

At the application layer
- the file to be transmitted is fragmented - the fragments are encapsulated in data packets which are passed to the link layer one by one
- in addition to data packets (which contain file fragments), the Application protocol uses control packets
	- the format of the packets (data and control) is defined ahead (slide 27 )

At the link layer each packet (data or control) is carried in the data field of an I frame

The Transmitter is the machine that sends the file and the Receiver is the machine that receives the file
- thus, only the Transmitter transmits packets (data or control) and therefore only the Transmitter transmits I frames

Both the Transmitter and the Receiver send and receive frames (write or read frames into/from the serial line)

All frames are delimited by flags (**01111110**)

A frame can be started with one or more flags, which must be taken into account by the frame reception mechanism

Frames I, SET and DISC are designated Commands and the rest (UA, RR and REJ) are called Replies

Frames have a header with a common format
- A (Address Field)
	- **00000011** (**0x03**) in Commands sent by the Transmitter and Replies sent by the Receiver
	- **00000001** (**0x01**) in Commands sent by the Receiver and Replies sent by the Transmitter
- C (Control Field) – defines frame type and carries sequence numbers N(s) in I frames and N(r) in Supervision frames (RR, REJ)
- BCC (Block Check Character) - error detection based on the generation of an octet (BCC) such that there is an even number of 1s in each position (bit), considering all octets protected by the BCC (header or data, as appropriate) and the BCC itself (before stuffing)

## Reception of frames

I, S or U frames with wrong header are ignored without any action

The data field of the I frames is protected by its own BCC (even parity on each bit of the data octets and the BCC)

I frames received with no errors detected in the header and data field are accepted for processing
- If it is a new frame, the data field is accepted (and passed to the Application), and the frame must be confirmed with RR
- If it is a duplicate, the data field is discarded, but the frame must be confirmed with RR
- I frames with no header error detected but error detected (by the respective BCC) in the data field – the data field is discarded, but the control field can be used to trigger an appropriate action
- If it is a new frame, it is convenient to make a retransmission request with REJ, which allows to anticipate the occurrence of time-out in the transmitter
- If it is a duplicate, it must be confirmed with RR

I, SET and DISC frames are protected by a timer
- In the event of a time-out, a maximum number of retransmission attempts must be made (the value must be configurable; for example, three)

## Transparency / Stuffing

The transmission between the two computers is, in this work, based on a technique called asynchronous transmission
- This technique is characterised by the transmission of "characters" (short string of bits, whose number can be configured) delimited by Start and Stop bits
- Some protocols use characters (words) of a code (for example ASCII) to delimit and identify the fields that constitute the frames and to support the execution of the protocol mechanisms

In these protocols, the transmission of data transparently (regardless of the code used by the protocol) requires the use of escape mechanisms
- The protocol to be implemented is not based on the use of any code, so the transmitted characters (consisting of 8 bits) must be interpreted as simple octets (bytes), and any of the 256 possible combinations can occur
- To avoid the false recognition of a flag inside a frame, a mechanism that guarantees transparency is needed


In the protocol to be implemented, the mechanism used in PPP is adopted, which uses the escape octet **01111101** (**0x7d**)
- If the octet **01111110** (**0x7e**) occurs inside the frame, i.e., the pattern that corresponds to a flag, the octet is replaced by the sequence **0x7d 0x5e** (escape octet followed by the result of the exclusive or of the octet replaced with the octet 0x20)
- If the octet 01111101 (0x7d) occurs inside the frame, i.e., the pattern that corresponds to the escape octet, the octet is replaced by the sequence **0x7d 0x5d** (escape octet followed by the result of the exclusive or of the octet replaced with the octet 0x20)
- In the BCC generation, only the original octets are considered (before the stuffing operation), even if some octet (including the BCC itself) has to be replaced by the corresponding escape sequence
- The verification of the BCC is carried out in relation to the original octets, i.e., after the inverse operation (destuffing) has been performed, if the replacement of any of the special octets by the corresponding escape sequence has occurred

Normal Routine
![[Pasted image 20241020222335.png]]

## Retransmissions

Acknowledgement / Error Control
- Stop-and-Wait

Timer
- Enabled after an I, SET or DISC frame
- Disabled after a valid acknowledgement
- If acceded (timeout), forces retransmission

I frames retransmission
- After a time-out, due to loss of the I frame or its acknowledgement
- Maximum number of predefined (configured) retransmission attempts
- After a receiving a negative acknowledgement (REJ)

Frame protection
- Generation and verification of the protection fields (BCC)